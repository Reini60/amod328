#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <avr/sleep.h>
#include <avr/wdt.h>
#include "ff.h"
#include "fdiskio.h"

#define YMODEM	1

void tx_single_byte( uint8_t byte ) ;

struct t_fifo32
{
	uint8_t fifo[32] ;
	uint8_t in ;
	uint8_t out ;
	volatile uint8_t count ;
} ;

struct t_fifo32 RxFifo ;

int16_t get_fifo32( )
{
	int32_t rxbyte ;
	struct t_fifo32 *pfifo = &RxFifo ;
	if ( pfifo->count )						// Look for char available
	{
		rxbyte = pfifo->fifo[pfifo->out] ;
		cli() ;
		pfifo->count -= 1 ;
		sei() ;
		pfifo->out = ( pfifo->out + 1 ) & 0x1F ;
		return rxbyte ;
	}
	return -1 ;
}

/*---------------------------------------------------------*/
/* 4000Hz timer interrupt generated by OC2                  */
/*---------------------------------------------------------*/
static uint8_t Pre_timer ;
static uint8_t rx_fifo_running ;
volatile uint8_t Ms_counter ;
ISR(TIMER2_COMPA_vect)
{
	if ( ++Pre_timer > 39 )
	{
		disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
		Pre_timer = 0 ;
	}
	if ( ( Pre_timer & 3 ) == 0 )
	{
		Ms_counter += 1 ;		
	}
	// Look at serial rx here
	if ( rx_fifo_running )
	{
	  if ((UCSR0A & _BV(RXC0)))
		{
			uint8_t chr ;
  		chr = UDR0 ;
			struct t_fifo32 *pfifo = &RxFifo ;
			pfifo->fifo[pfifo->in] = chr ;
			cli() ;
			pfifo->count += 1 ;
			sei() ;
			pfifo->in = ( pfifo->in + 1) & 0x1F ;
		}
	}
}

#ifdef YMODEM

#define PACKET_SEQNO_INDEX      (1)
#define PACKET_SEQNO_COMP_INDEX (2)

#define PACKET_HEADER           (3)
#define PACKET_TRAILER          (2)
#define PACKET_OVERHEAD         (PACKET_HEADER + PACKET_TRAILER)
#define PACKET_SIZE             (128)
#define PACKET_1K_SIZE          (1024)

#define FILE_NAME_LENGTH        (116)
#define FILE_SIZE_LENGTH        (16)

#define SOH                     (0x01)  /* start of 128-byte data packet */
#define STX                     (0x02)  /* start of 1024-byte data packet */
#define EOT                     (0x04)  /* end of transmission */
#define ACK                     (0x06)  /* acknowledge */
#define NAK                     (0x15)  /* negative acknowledge */
#define CA                      (0x18)  /* two of these in succession aborts transfer */
//#define CRC16                   (0x43)  /* 'C' == 0x43, request 16-bit CRC */

#define ABORT1                  (0x41)  /* 'A' == 0x41, abort by user */
#define ABORT2                  (0x61)  /* 'a' == 0x61, abort by user */

#define NAK_TIMEOUT             (100)	// Units of 2mS 
#define PACKET_TIMEOUT          (25)		// Units of 2mS 
#define MAX_ERRORS              (5)

int8_t Ymodem_Receive (uint8_t *p ) ;

uint8_t file_name[FILE_NAME_LENGTH];

uint8_t packet_data[PACKET_SIZE + PACKET_OVERHEAD] ;

static int8_t Receive_Byte (uint8_t *c, uint16_t timeout)
{
	uint16_t rxchar ;

	while ( ( rxchar = get_fifo32() ) == 0xFFFF )
	{
//		wait 2mS
		{
			uint8_t t ;
			t = Ms_counter ;
			while ( (uint8_t)(Ms_counter-t) < (uint8_t) 2 )
			{
				// wait
			}
		}		
		timeout -= 1 ;
		if ( timeout == 0 )
		{
			break ;			
		}
	}
	if ( rxchar == 0xFFFF )
	{
    return -1;
	}
	*c = rxchar ;
	return 0 ;
}

/*******************************************************************************
* Function Name  : Send_Byte
* Description    : Send a byte
* Input          : - c: Character
* Output         : None
* Return         : 0: Byte sent
*******************************************************************************/
static uint8_t Send_Byte (uint8_t c)
{
  tx_single_byte( c ) ;
  return 0 ;
}

/*******************************************************************************
* Function Name  : Receive_Packet
* Description    : Receive a packet from sender
* Input 1        : - data
* Input 2        : - length
* Input 3        : - timeout
* Output         : *length:
*                  0: end of transmission
*                  -1: abort by sender
*                  >0: packet length
* Return         : 0: normally return
*                  -1: timeout or packet error
*                  1: abort by user
*******************************************************************************/
static int8_t Receive_Packet (uint8_t *data, int16_t *length, uint16_t timeout)
{
  uint16_t i, packet_size;
  uint8_t c;
  *length = 0;

  if (Receive_Byte(&c, timeout) != 0)
  {
    return -1;
  }
	
  switch (c)
  {
    case SOH:
      packet_size = PACKET_SIZE;
      break;
    case STX:
      packet_size = PACKET_1K_SIZE;
      break;
    case EOT:
  		*length = 0 ;
      return 0;
    case CA:
      if ((Receive_Byte(&c, timeout) == 0) && (c == CA))
      {
        *length = -1;
        return 0;
      }
      else
      {
        return -1;
      }
    case ABORT1:
    case ABORT2:
      Send_Byte(c);
      return 1;
    default:
      return -1;
  }
  *data = c;
  for (i = 1; i < (packet_size + PACKET_OVERHEAD); i ++)
  {
    if (Receive_Byte(data + i, PACKET_TIMEOUT) != 0)
    {
//      Send_Byte('?');
      return -1;
    }
  }
  if (data[PACKET_SEQNO_INDEX] != ((data[PACKET_SEQNO_COMP_INDEX] ^ 0xff) & 0xff))
  {
//    Send_Byte('£');
    return -1;
  }
  *length = packet_size;
  return 0;
}

FATFS Fs;			/* File system object */

//void hex2( uint8_t x )
//{
//	Send_Byte(((x >> 4) & 0x0F) + '0') ;
//  Send_Byte((x & 0x0F) + '0') ;
//}

void ymount()
{
	f_mount( 0, &Fs ) ;
//	int i ;
//	i = f_mount( 0, &Fs ) ;
//	tx_single_byte( 'M' ) ;
//	hex2(i) ;
}	 


/*******************************************************************************
* Function Name  : Ymodem_Receive
* Description    : Receive a file using the ymodem protocol
* Input          : Address of the first byte
* Output         : None
* Return         : The size of the file
*******************************************************************************/

FIL Tfile ;

uint8_t checksumBlockChk( uint8_t *block )
{
	uint16_t csum ;
	int i ;
	uint16_t actcsum ;

	csum = 0 ;
	block += 3 ;
	for ( i = 0 ; i < 128 ; i += 1 )
	{
		csum += *block++ ;		
	}
	actcsum = *block++ ;
	actcsum |= *block << 8 ;
	return (actcsum == csum) ;
}

TCHAR *Tempfile = "Ymodtemp" ;

void ymodem_Receive()
{
  uint8_t *file_ptr; //, *buf_ptr;
  int16_t i, packet_length, session_done, file_done, packets_received, errors, session_begin ;
	FRESULT fr ;
	uint32_t written ;
	uint32_t size ;

	size = 0 ;
  file_name[0] = 0 ;
	rx_fifo_running = 1 ;

  for (session_done = 0, errors = 0, session_begin = 0; ;)
  {
    for (packets_received = 0, file_done = 0 /*, buf_ptr = buf*/; ;)
    {
      switch (Receive_Packet(packet_data, &packet_length, NAK_TIMEOUT))
      {
        case 0:
          errors = 0;
          switch (packet_length)
          {
              /* Abort by sender */
            case -1:
              Send_Byte(ACK);
							fr = f_close( &Tfile ) ;
              return ;
              /* End of transmission */
            case 0:
							fr = f_close( &Tfile ) ;
              Send_Byte(ACK);
              file_done = 1;
              break;
              /* Normal packet */
            default:
              if ((packet_data[PACKET_SEQNO_INDEX] & 0xff) != (packets_received & 0xff))//
              {
                Send_Byte(NAK);
              }
              else
              {
                if (packets_received == 0)
                {/* Filename packet */
                  if (packet_data[PACKET_HEADER] != 0)
                  {/* Filename packet has valid data */
										if ( checksumBlockChk( packet_data ) )
										{
											size = 0 ;
										  file_name[0] = 0 ;
											
                    	for (i = 0, file_ptr = packet_data + PACKET_HEADER; (*file_ptr != 0) && (i < FILE_NAME_LENGTH);)
                    	{
                    	  file_name[i++] = *file_ptr++;
                    	}
                    	file_name[i++] = '\0';
                    	for (i = 0, file_ptr += 1; (*file_ptr) && (i < FILE_SIZE_LENGTH);)
                    	{
												size *= 10 ;
												size += *file_ptr++ - '0' ;
                    	}
											f_unlink ( Tempfile ) ;					/* Delete any existing temp file */
											fr = f_open( &Tfile, Tempfile, FA_WRITE | FA_CREATE_ALWAYS ) ;

		  	// Check fr value here

                    	Send_Byte(ACK);
//                    	Send_Byte(CRC16);
  			              packets_received ++;
										}
										else
										{
                    	Send_Byte(NAK);
//                    	Send_Byte(CRC16);
										}
                  }
                  /* Filename packet is empty, end session */
                  else
                  {
                    Send_Byte(ACK);
                    file_done = 1;
                    session_done = 1;
                    break;
                  }
                }
                else
                { /* Data packet */
									if ( checksumBlockChk( packet_data ) )
									{
										if ( size > 128 )
										{
											i = 128 ;
											size -= 128 ;
										}
										else
										{
											i = size ;
											size = 0 ;
										}
										if ( i )
										{
											fr = f_write( &Tfile, &packet_data[3], i, (UINT *)&written ) ;
											// should check fr here
										}
                  	Send_Byte(ACK);
	                	packets_received ++;
									}
									else
									{
                  	Send_Byte(NAK) ;
									}
                }
                session_begin = 1;
              }
							(void)fr ;
          }
          break;
        case 1:
          Send_Byte(CA);
          Send_Byte(CA);
          return ;
        default:
          if (session_begin > 0)
          {
            errors ++;
          }
          if (errors > MAX_ERRORS)
          {
            Send_Byte(CA);
            Send_Byte(CA);
						fr = f_close( &Tfile ) ;
            return ;
          }
//          Send_Byte(CRC16);
          break;
      }
      if (file_done != 0)
      {
        break;
      }
    }
		f_unlink( (const TCHAR *)file_name ) ;	/* Delete existing file */
		f_rename( Tempfile, (const TCHAR *)file_name ) ;		/* Rename/Move a file or directory */
    
		if (session_done != 0)
    {
      break;
    }
  }

	rx_fifo_running = 0 ;
  return ;
}

#endif



